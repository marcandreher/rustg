AddCSLuaFile()


DEFINE_BASECLASS("rust_base")

ENT.Base = "rust_base"

ENT.AutomaticFrameAdvance = true



ENT.DisplayIcon     = gRust.GetIcon("add")

ENT.ShowHealth      = true



function ENT:SetupDataTables()

    BaseClass.SetupDataTables(self)

    self:NetworkVar("Bool", 1, "Running")

end

ENT.AutomaticFrameAdvance = true

ENT.health = 750

ENT.fuel = 500

ENT.xdiff = 0

ENT.ydiff = 0

ENT.storedxdiff = 0

ENT.storedydiff = 0

ENT.storedVector = Vector(0, 0, 0)

ENT.activeVector = Vector(0, 0, 0)

ENT.sinAngleY = 0

ENT.cosAngleY = 0

ENT.resetView = false

ENT.addPos = Vector(0, 0, 0)

ENT.firstStart = false

ENT.engineActive = false

ENT.collisionDelay = 0

ENT.diffVel = 0

ENT.fuelTime = 0

ENT.rustminicopter = true



sound.Add({

    name = "rust_minicopter_rotor_loop",

    channel = CHAN_STATIC,

    volume = 0.4,

    level = 75,

    sound = "vehicles/rust/minicopter/rotors-loop-close.wav"

})



sound.Add({

    name = "rust_minicopter_rotor_loop_close",

    channel = CHAN_STATIC,

    volume = 1,

    level = 75,

    sound = "vehicles/rust/minicopter/engine-loop-close.wav"

})



sound.Add({

    name = "rust_minicopter_starting",

    channel = CHAN_STATIC,

    volume = 1,

    level = 75,

    sound = "vehicles/rust/minicopter/engine-start-close.wav"

})



sound.Add({

    name = "rust_minicopter_stopping",

    channel = CHAN_STATIC,

    volume = 1,

    level = 75,

    sound = "vehicles/rust/minicopter/engine-stop-close.wav"

})



sound.Add({

    name = "rust_minicopter_stop_close",

    channel = CHAN_STATIC,

    volume = 0.5,

    level = 75,

    sound = "vehicles/rust/minicopter/rotors-stop-close.wav"

})



sound.Add({

    name = "rust_minicopter_gib",

    channel = CHAN_STATIC,

    volume = 1,

    level = 100,

    sound = "vehicles/rust/minicopter/metal_gib-3.wav"

})



sound.Add({

    name = "rust_minicopter_explosion",

    channel = CHAN_STATIC,

    volume = 1,

    level = 100,

    sound = "vehicles/rust/minicopter/rocket_explosion.wav"

})



function ENT:SpawnFunction(ply, tr, className)

    if not tr.Hit then return end

    local spawnPos = tr.HitPos + tr.HitNormal * 25

    local ent = ents.Create(className)

    ent:Spawn()

    ent:Activate()

    ent:SetPos(spawnPos)

    ent.Owner = ply



    return ent

end



function ENT:SetupDataTables()

    BaseClass.SetupDataTables(self)

    self:NetworkVar("Int", self.health, "Health")

    self:NetworkVar("Int", self.fuel, "Fuel")



    if SERVER then

        self:SetHealth(self.health)

        self:SetFuel(self.fuel)

    end

end



if SERVER then

    util.AddNetworkString("rust_minicopter")



    hook.Add("PlayerLeaveVehicle", "rustminicopter_ejection", function(ply, vehicle)

        if vehicle.rustminicp and vehicle.rustminicp:IsValid() then

            if ply.minicpChangeSeat then

                ply.minicpChangeSeat = nil

            else

                vehicle.rustminicp:ejectPlayer(ply, vehicle)

            end

        end

    end)

else

    ENT.startTime = 0

    ENT.stopTime = 0

    language.Add("rust_minicopter", "Minicopter")

    killicon.Add("rust_minicopter", "vgui/rust_minicopter", Color(255, 255, 255, 255))



    net.Receive("rust_minicopter", function(len)

        local process = net.ReadUInt(3)



        if process == 1 then

            local ent = net.ReadEntity()

            local driver = net.ReadBool()

            local ang = Angle(0, ent:GetAngles().y, 0)

            LocalPlayer().rustminicp = ent

            LocalPlayer().rustminicpdriver = driver

            LocalPlayer():SetEyeAngles(ang)

        elseif process == 2 then

            LocalPlayer().rustminicp = nil

        elseif process == 3 then

            local ent = net.ReadEntity()

            local health = net.ReadUInt(10)

            if not IsValid(ent) then return end



            if ent.SetHealth then

                ent:SetHealth(health)

            end



            ent.health = health

        elseif process == 4 then

            local ent = net.ReadEntity()

            local fuel = net.ReadUInt(9)

            if not IsValid(ent) then return end



            if ent.SetFuel then

                ent:SetFuel(fuel)

            end



            -- Below function generated by Lagrange Interpolation Polynomial Calculator for the fuel gauge, when the distance is close than 500, will be calculated

            if LocalPlayer():GetPos():DistToSqr(ent:GetPos()) < 250000 then

                ent:ManipulateBoneAngles(1, Angle(0, 1 / 1171875000 * fuel ^ 4 - 3 / 7812500 * fuel ^ 3 - 101 / 375000 * fuel ^ 2 + 243 / 500 * fuel - 106, 1 / 585937500 * fuel ^ 4 - 2 / 1171875 * fuel ^ 3 - 1 / 37500 * fuel ^ 2 + 17 / 75 * fuel))

            end



            ent.fuel = fuel

        elseif process == 5 then

            local ent = net.ReadEntity()

            if not IsValid(ent) then return end

            ent.engineActive = net.ReadBool()

        end

    end)



    local minicp_cooldown = 0



    hook.Add("PlayerButtonDown", "rustminicopter_keypress", function(ply, button)

        if button == 34 and IsValid(ply.rustminicp) and CurTime() > minicp_cooldown then

            minicp_cooldown = CurTime() + 1

            net.Start("rust_minicopter")

            net.SendToServer()

        end

    end)



    hook.Add("CalcView", "rustminicopter_calcview", function(ply, pos, ang, fov)

        if IsValid(ply.rustminicp) then

            --ply:GetVehicle():SetThirdPersonMode(false)



            if ply.rustminicpdriver and (not ply:KeyDown(IN_WALK)) then

                view = {

                    angles = ply:GetAngles(),

                    drawviewer = false

                }



                return view

            end

        end

    end)



    function ENT:enableEffects()

        if self.engineActive then

            if not self.isActiveCL then

                self.isActiveCL = true

                self.startTime = CurTime()



                if CurTime() - self.stopTime < 0.5 then

                    self.startTime = self.startTime - 3

                end

            end



            if self.startTime + 3 > CurTime() then

                self:SetPoseParameter("spin", (-math.exp(3 * (CurTime() - self.startTime))) % 360)

            else

                self:SetBodygroup(1, 1)

                self:SetBodygroup(2, 1)

                self:SetPoseParameter("spin", (CurTime() * -100000) % 360)

                self:InvalidateBoneCache()

            end

        else

            if self.isActiveCL then

                self.isActiveCL = false

                self.isStopping = true

                self.stopTime = CurTime()

                self:SetBodygroup(1, 0)

                self:SetBodygroup(2, 0)

            end



            if self.isStopping and self.stopTime + 3 > CurTime() then

                self:SetPoseParameter("spin", (math.exp(3 * ((self.stopTime + 3) - CurTime()))) % 360)

            else

                self.isStopping = false

            end

        end

    end

end



function ENT:Think()

    if SERVER then

        self:soundThink()



        if IsValid(self.driver) and self.fuel > 0 then

            if not self.isActive then

                self.engineActive = true

                net.Start("rust_minicopter")

                net.WriteUInt(5, 3)

                net.WriteEntity(self)

                net.WriteBool(true)

                net.Broadcast()

                self.isActiveTime = CurTime()

                self.isActive = true

            end

        else

            if self.isActive then

                self.engineActive = false

                net.Start("rust_minicopter")

                net.WriteUInt(5, 3)

                net.WriteEntity(self)

                net.WriteBool(false)

                net.Broadcast()

                self.isStopTime = CurTime()

                self.isActive = false

            end

        end

    else

        self:enableEffects()

    end



    self:NextThink(CurTime())



    return true

end



function ENT:soundThink()

    if not self.rotorSound then

        if SERVER then

            local filter = RecipientFilter()

            filter:AddAllPlayers()

        end



        self.rotorSound = CreateSound(self, "rust_minicopter_rotor_loop", filter)

        self.rotorSound:SetSoundLevel(95)

        self.rotorSound2 = CreateSound(self, "rust_minicopter_rotor_loop_close", filter)

        self.rotorSound2:SetSoundLevel(75)

        self.startingSound = CreateSound(self, "rust_minicopter_starting", filter)

        self.startingSound:SetSoundLevel(75)

        self.stoppingSound = CreateSound(self, "rust_minicopter_stopping", filter)

        self.stoppingSound:SetSoundLevel(75)

        self.stopsound = CreateSound(self, "rust_minicopter_stop_close", filter)

        self.stopsound:SetSoundLevel(80)

    end



    if self.isActive then

        if self.rotorActive then

            self.rotorSound2:Play()

        else

            if CurTime() > self.isActiveTime + 1.25 and (not self.rotorSound2:IsPlaying()) then

                self.rotorSound2:Play()

            end



            if CurTime() > self.isActiveTime + 3 then

                self.rotorSound:Play()

                self.rotorActive = true

                self.firstStart = true

                self:StartMotionController()

                local phys = self:GetPhysicsObject()



                if phys:IsValid() then

                    phys:Wake()

                end

            end



            self.startingSound:Play()

        end

    elseif not self.isActive then

        if self.rotorActive then

            if CurTime() > self.isStopTime + 0.75 then

                self.rotorSound:Stop()

                self.stoppingSound:Stop()

                self.firstStart = false

                self:StopMotionController()

                self.stopsound:Play()

                self.rotorActive = false



                timer.Simple(2, function()

                    if self.stopsound then

                        self.stopsound:Stop()

                    end

                end)

            end



            if self.rotorSound2:IsPlaying() then

                self.rotorSound2:Stop()

                self.startingSound:Stop()

                self.stoppingSound:Play()

            end

        else

            if self.startingSound:IsPlaying() then

                self.startingSound:Stop()

                self.rotorSound:Stop()

                self.rotorSound2:Stop()

                self.stoppingSound:Play()



                timer.Simple(2, function()

                    if self.stoppingSound then

                        self.stoppingSound:Stop()

                    end

                end)

            end

        end

    end

end



function ENT:Initialize()

    if SERVER then

        self:SetModel("models/vehicles/darky_m/rust/minicopter.mdl")

        self:PhysicsInit(SOLID_VPHYSICS)

        self:SetMoveType(MOVETYPE_VPHYSICS)

        self:SetSolid(SOLID_VPHYSICS)

        self:SetUseType(SIMPLE_USE)

        self:SetDamageable(true)

	    self:SetDamageSound(true)

        

        self:SetMeleeDamage(1.5)

        self:SetBulletDamage(2)

        self:SetExplosiveDamage(5)



        local phys = self:GetPhysicsObject()



        if IsValid(phys) then

            phys:SetMass(800)



            timer.Simple(0.15, function()

                if IsValid(phys) then

                    phys:Wake()

                end

            end)

        end



        local randomid = math.random(2023)



        timer.Create("decaying_minicopter_" .. self:EntIndex() .. "_" .. randomid, 300, 0, function()

            if IsValid(self) then

                self:Decay()

            else

                timer.Remove("decaying_minicopter_" .. randomid)

            end

        end)



        self.seatDriver = ents.Create("prop_vehicle_prisoner_pod")

        self.seatDriver:SetModel("models/nova/jeep_seat.mdl")

        self.seatDriver:SetPos(self:LocalToWorld(Vector(8.5, 0, 17)))

        self.seatDriver:SetAngles(self:LocalToWorldAngles(Angle(0, -90, 0)))

        self.seatDriver:SetSolid(SOLID_NONE)

        self.seatDriver:SetKeyValue("limitview", 0)

        self.seatDriver:SetNoDraw(true)

        self.seatDriver:Spawn()

        self.seatDriver:Activate()

        self.seatDriver:SetParent(self)

        self.seatDriver:SetNotSolid(true)

        self:DeleteOnRemove(self.seatDriver)

        self.seatDriver.rustminicp = self

        self.seatDriver:SetThirdPersonMode(false)

        self.seatDriver:DrawShadow(false)

        self.seatGunner = ents.Create("prop_vehicle_prisoner_pod")

        self.seatGunner:SetModel("models/nova/jeep_seat.mdl")

        self.seatGunner:SetPos(self:LocalToWorld(Vector(42.5, 0, 11)))

        self.seatGunner:SetAngles(self:LocalToWorldAngles(Angle(0, -90, 0)))

        self.seatGunner:SetSolid(SOLID_NONE)

        self.seatGunner:SetKeyValue("limitview", 0, 0)

        self.seatGunner:SetNoDraw(true)

        self.seatGunner:Spawn()

        self.seatGunner:SetParent(self)

        self.seatGunner:SetNotSolid(true)

        self:DeleteOnRemove(self.seatGunner)

        self.seatGunner.rustminicp = self

        self.seatGunner:SetThirdPersonMode(false)

        self:SetMaxHealth(self.health)

        self:SetHealth(self:GetMaxHealth())

        self:SetFuel(self.fuel)

        self.lastPercentage = 100

        self.driver, self.gunner = nil

        self.storedPos = Vector(0, 0, 0)

        self.storedVel = Vector(0, 0, 0)

        self.storedPitch = 0

        self.storedYaw = 0

        self.isActive = false

        self.passengers = {}

        self.SpeedMult = 1000



        timer.Simple(1, function()

            self:NetworkNotifyPVS(true)

            self:NetworkNotifyPVS(false)

        end)

    else

        --Initializing the gauge on client

        self:ManipulateBoneAngles(1, Angle(0, 1 / 1171875000 * self.fuel ^ 4 - 3 / 7812500 * self.fuel ^ 3 - 101 / 375000 * self.fuel ^ 2 + 243 / 500 * self.fuel - 106, 1 / 585937500 * self.fuel ^ 4 - 2 / 1171875 * self.fuel ^ 3 - 1 / 37500 * self.fuel ^ 2 + 17 / 75 * self.fuel))

    end

end



if SERVER then

    function ENT:NetworkNotifyPVS(health)

        if health then

            net.Start("rust_minicopter")

            net.WriteUInt(3, 3)

            net.WriteEntity(self)

            net.WriteUInt(self.health, 10)

            net.SendPVS(self:GetPos())

        else

            net.Start("rust_minicopter")

            net.WriteUInt(4, 3)

            net.WriteEntity(self)

            net.WriteUInt(self.fuel, 9)

            net.SendPVS(self:GetPos())

        end

    end



    function ENT:Use(ply)

        local hitpos = self:WorldToLocal(ply:GetEyeTrace().HitPos)



        if not self.driver then

            ply:EnterVehicle(self.seatDriver)

            ply:SetAllowWeaponsInVehicle(false)

            self.driver = ply

            ply.rustminicp = self

            ply.rustminicpdriver = true

            net.Start("rust_minicopter")

            net.WriteUInt(1, 3)

            net.WriteEntity(self)

            net.WriteBool(true)

            net.Send(ply)

        elseif not self.gunner then

            ply:EnterVehicle(self.seatGunner)

            ply:SetAllowWeaponsInVehicle(true)

            self.gunner = ply

            ply.rustminicpdriver = nil

            ply.rustminicp = self

            net.Start("rust_minicopter")

            net.WriteUInt(1, 3)

            net.WriteEntity(self)

            net.WriteBool(false)

            net.Send(ply)

        elseif hitpos:WithinAABox(Vector(-25, -6, 0), Vector(-4, 6, 44)) then

            self:EmitSound("vehicles/rust/minicopter/small-boat-" .. (math.random(1, 2) == 1 and "close" or "open") .. "-fuel-container.wav")

        else

            self:GetPhysicsObject():SetVelocity(ply:GetAimVector() * 100)

        end

    end



    function ENT:OnRemove()

        if self.rotorSound then

            self.rotorSound:Stop()

        end



        if self.rotorSound2 then

            self.rotorSound2:Stop()

        end



        if self.startingSound then

            self.startingSound:Stop()

        end



        if self.stopsound then

            self.stopsound:Stop()

        end

    end



    function ENT:Decay()

        local outside = util.QuickTrace(self:GetPos() + Vector(0, 0, 50), self:GetPos() + Vector(999999, 0, 50), self).HitWorld or util.QuickTrace(self:GetPos() + Vector(0, 0, 50), self:GetPos() + Vector(999999, 0, 50), self).HitWorld or util.QuickTrace(self:GetPos() + Vector(0, 0, 50), self:GetPos() + Vector(0, -999999, 50), self).HitWorld or util.QuickTrace(self:GetPos() + Vector(0, 0, 50), self:GetPos() + Vector(0, 999999, 50), self).HitWorld or util.QuickTrace(self:GetPos() + Vector(0, 0, 50), self:GetPos() + Vector(0, 0, 999999), self).HitWorld

        self.health = self.health - (outside and 5.21 or 0.87) --Inside 48 hours, outside 8 hours. The mini is getting damage every 300 seconds.

        self:SetHealth(self.health)

        self:ProcessDamage()

    end



    local minicpcooldown = {}



    net.Receive("rust_minicopter", function(len, ply)

        if (not IsValid(ply)) or (not ply.rustminicp) or ((minicpcooldown[ply] or 0) > CurTime()) then return end

        minicpcooldown[ply] = CurTime() + 1



        if ply == ply.rustminicp.driver and (not IsValid(ply.rustminicp.gunner)) then

            local seat = ply.rustminicp.seatGunner

            ply.minicpChangeSeat = true

            ply:ExitVehicle()

            ply:EnterVehicle(seat)

            ply.minicpChangeSeat = nil

            ply.rustminicp.gunner = ply

            ply.rustminicpdriver = nil

            net.Start("rust_minicopter")

            net.WriteUInt(1, 3)

            net.WriteEntity(ply.rustminicp)

            net.WriteBool(false)

            net.Send(ply)

            ply.rustminicp.driver = nil

            ply:SetAllowWeaponsInVehicle(true)

            ply:EmitSound("buttons/lightswitch2.wav")

        elseif ply == ply.rustminicp.gunner and (not IsValid(ply.rustminicp.driver)) then

            local seat = ply.rustminicp.seatDriver

            ply.minicpChangeSeat = true

            ply:ExitVehicle()

            ply:EnterVehicle(seat)

            ply.minicpChangeSeat = nil

            ply.rustminicp.driver = ply

            ply.rustminicpdriver = true

            net.Start("rust_minicopter")

            net.WriteUInt(1, 3)

            net.WriteEntity(ply.rustminicp)

            net.WriteBool(true)

            net.Send(ply)

            ply.rustminicp.gunner = nil

            ply:SetAllowWeaponsInVehicle(false)

            ply:EmitSound("buttons/lightswitch2.wav")

        end

    end)



    function ENT:ejectPlayer(ply, vehicle)

        ply.rustminicp = nil

        ply.rustminicpdriver = nil

        net.Start("rust_minicopter")

        net.WriteUInt(2, 3)

        net.Send(ply)



        if self.driver == ply then

            self.driver = nil

            ply:SetPos(self:LocalToWorld(Vector(15, 40, 5)))

        elseif self.gunner == ply then

            self.gunner = nil

            ply:SetPos(self:LocalToWorld(Vector(50, 35, 5)))

        end



        ply:SetVelocity(self:GetVelocity())

    end



    function ENT:ProcessDamage()

        if self.health <= 0 then

            self:StopMotionController()

            self:CreateGibs()



            if self.fuel > 0 then

                util.BlastDamage(self, self.driver or self or game.GetWorld(), self:GetPos(), 350, 100)

                util.ScreenShake(self:GetPos(), 100, 10, 1, 1000)

            end



            if IsValid(self.driver) and self.driver:IsPlayer() then

                self.driver:TakeDamage(1000, self, self)

            end



            if IsValid(self.gunner) and self.gunner:IsPlayer() then

                self.gunner:TakeDamage(1000, self, self)

            end



            SafeRemoveEntity(self.fire)

            SafeRemoveEntity(self.smoke)

            SafeRemoveEntity(self.seatDriver)

            SafeRemoveEntity(self.seatGunner)

            SafeRemoveEntity(self)

        elseif self.health <= 100 then

            if not self.fire then

                self.fire = ents.Create("env_fire_trail")

                self.fire:SetPos(self:GetPos() + Vector(-20 * math.cos(math.rad(self:GetAngles().y)), -20 * math.sin(math.rad(self:GetAngles().y)), 40))

                self.fire:SetParent(self)

                self.fire:Spawn()

                self.fire:Activate()

            end

        else

            if IsValid(self.fire) then

                self.fire:Remove()

                self.fire = nil

            end

        end



        self:NetworkNotifyPVS(true)

    end



    function ENT:OnTakeDamage(dmgInfo)

        

        BaseClass.OnTakeDamage(self, dmgInfo)

        if dmgInfo:GetInflictor() == self then return end

        self.health = self.health - dmgInfo:GetDamage() * 3

        self:SetHealth(self.health)

        self:ProcessDamage()

    end



    local minicopterGibs = {"models/vehicles/darky_m/rust/minicopter_gib0.mdl", "models/vehicles/darky_m/rust/minicopter_gib1.mdl", "models/vehicles/darky_m/rust/minicopter_gib2.mdl", "models/vehicles/darky_m/rust/minicopter_gib3.mdl", "models/vehicles/darky_m/rust/minicopter_gib4.mdl", "models/vehicles/darky_m/rust/minicopter_gib5.mdl", "models/vehicles/darky_m/rust/minicopter_gib6.mdl", "models/vehicles/darky_m/rust/minicopter_gib7.mdl", "models/vehicles/darky_m/rust/minicopter_gib8.mdl", "models/vehicles/darky_m/rust/minicopter_gib9.mdl"}



    function ENT:CreateGibs()

        for _, v in pairs(minicopterGibs) do

            local ent = ents.Create("prop_physics")

            ent:Ignite(30)



            if IsValid(ent) then

                ent:SetPos(self:GetPos())

                ent:SetAngles(self:GetAngles())

                ent:SetModel(v)

                ent:SetMaterial("models/darky_m/rust/minicopter/minicoptor prt 1")

                ent:SetRenderMode(RENDERMODE_TRANSALPHA)

                ent:SetCollisionGroup(COLLISION_GROUP_WORLD)

                ent:Spawn()

                ent:Activate()



                if self.fuel > 0 and math.random(1, 8) == 3 then

                    local random = math.random(15, 25)

                    ent:Ignite(random)



                    timer.Simple(random - 1, function()

                        if IsValid(ent) then

                            ent:Extinguish()

                        end

                    end)

                end



                if v == "models/vehicles/darky_m/rust/minicopter_gib1.mdl" then

                    local fltr = RecipientFilter()

                    fltr:AddAllPlayers()

                    ent.gibsound = CreateSound(ent, "rust_minicopter_gib", fltr)

                    ent.gibsound:SetSoundLevel(100)

                    ent.gibsound:Play()



                    timer.Simple(3, function()

                        if ent and ent.gibsound then

                            ent.gibsound:Stop()

                            ent.gibsound = nil

                        end

                    end)



                    if self.fuel > 0 then

                        ent.expsound = CreateSound(ent, "rust_minicopter_explosion", fltr)

                        ent.expsound:SetSoundLevel(100)

                        ent.expsound:Play()



                        timer.Simple(3, function()

                            if ent and ent.expsound then

                                ent.expsound:Stop()

                                ent.expsound = nil

                            end

                        end)

                    end

                end



                SafeRemoveEntityDelayed(ent, 30)

                local PhysObj = ent:GetPhysicsObject()



                if IsValid(PhysObj) then

                    PhysObj:SetVelocityInstantaneous(VectorRand() * math.max(300, self.storedVel:Length() / 3) + self.storedVel)

                    PhysObj:AddAngleVelocity(VectorRand() * 500)

                    PhysObj:EnableDrag(false)



                    if self.fuel > 0 then

                        local effectdata = EffectData()

                        effectdata:SetOrigin(ent:GetPos())

                        effectdata:SetStart(PhysObj:GetMassCenter())

                        effectdata:SetEntity(ent)

                        effectdata:SetScale(math.Rand(0.3, 0.7))

                        effectdata:SetMagnitude(math.Rand(0.5, 2.5))

                        util.Effect("minicopter_firetrail", effectdata)

                    end

                end



                timer.Simple(29 + math.Rand(0, 0.5), function()

                    if not IsValid(ent) then return end

                    ent:SetRenderFX(kRenderFxFadeFast)

                end)

            end

        end

    end



    function ENT:PhysicsCollide(colData, phys)

        -- Stopping movement when a collision occured

        self.xdiff = 0

        self.ydiff = 0

        self.storedxdiff = 0

        self.storedydiff = 0

        self.addPos.x = self.addPos.x / 1.5

        self.addPos.y = self.addPos.y / 1.5

        if IsValid(colData.HitEntity) and colData.HitEntity:IsPlayer() then return end

        local collisionZ = math.max(self:WorldToLocal(colData.HitPos).z, 1) / 5 -- Between from bottom to top collision damage is different



        -- If minicopter is turned down, explode (:

        if (self:GetAngles().z > 90 and self:GetAngles().z <= 180) or (self:GetAngles().z < -90 and self:GetAngles().z >= -180) then

            self.health = 0

            self:SetHealth(self.health)

        elseif colData.Speed > (300 - collisionZ * 70) and CurTime() > self.collisionDelay then

            self.collisionDelay = CurTime() + 0.05

            self.health = self.health - colData.Speed * collisionZ * math.Remap(self.diffVel, 0, 5, 1, 5) / 8

            self:SetHealth(self.health)

            local effectdata = EffectData()

            effectdata:SetOrigin(colData.HitPos)

            effectdata:SetNormal(colData.HitNormal)

            util.Effect("minicopter_crash", effectdata)

            self:EmitSound("vehicles/rust/minicopter/minicopter-damaged-00" .. math.random(1, 4) .. ".wav", 100, math.random(80, 120), 1, CHAN_AUTO)

        end



        self:ProcessDamage()

    end



    function ENT:PhysicsSimulate(phys, delta)

        --local avel = phys:GetAngleVelocity()

        local vel = phys:GetVelocity()

        local desiredPitch = -(self.storedVel:Dot(self:GetForward()) - vel:Dot(self:GetForward())) * 3

        local desiredRoll = -(self.storedVel:Dot(self:GetRight()) - vel:Dot(self:GetRight())) * 3

        local pLerp = 1 - math.sin(delta * math.pi * 0.5)

        desiredPitch = Lerp(pLerp * delta + delta, self.storedPitch, desiredPitch)

        self.storedPitch = desiredPitch

        self.storedVel = vel

        local desiredPos = self:GetPos()

        local desiredYaw = self:GetAngles().y

        local ply = self.driver

        local enableControl = true



        if ply and ply:IsValid() then

            if CurTime() > self.fuelTime then

                self.fuel = self.fuel - 1

                self:SetFuel(self.fuel)

                self.fuelTime = CurTime() + 2 -- using 30 fuel per minute of flight

                self:NetworkNotifyPVS(false)



                if self.fuel <= 0 then

                    self:StopMotionController()

                end

            end



            self:SetPhysicsAttacker(ply, 10)

            self.addPos = Vector(0, 0, 0)



            if ply:KeyDown(IN_WALK) then

                self.resetView = true

            else

                self.storedVector = self:WorldToLocalAngles(ply:EyeAngles())

                ply:SetEyeAngles((self:GetPos() + Vector(0, 100, 50) - ply:GetShootPos()):Angle())

                self.activeVector = self:WorldToLocalAngles(ply:EyeAngles())



                if self.resetView then

                    self.storedVector = self.activeVector

                    self.resetView = false

                end

            end



            if self.firstStart then

                self.storedVector = self.activeVector

                self.firstStart = false

            end



            if not self.resetView then

                -- Getting differentiation of the eye angles of driver in order to turn to desired angle via the aim pos

                self.xdiff = math.Clamp(self.xdiff + math.Remap(math.Round(self.activeVector.x - self.storedVector.x), -750, 750, -1.2, 1.2) * (1 - self.diffVel / 20), -10, 10)

                self.ydiff = math.Clamp(self.ydiff + math.Remap(math.min(math.Round(self.activeVector.y - self.storedVector.y), 30), -1000, 1000, -1, 1) * (1 - self.diffVel / 20), -15, 15)

                self.sinAngleY = math.sin(math.rad(self:GetAngles().y))

                self.cosAngleY = math.cos(math.rad(self:GetAngles().y))



                if self.xdiff > 0 and self.xdiff > self.storedxdiff then

                    self.storedxdiff = self.storedxdiff + self.xdiff / 10

                elseif self.xdiff < 0 and self.xdiff < self.storedxdiff then

                    self.storedxdiff = self.storedxdiff + self.xdiff / 10

                else

                    self.storedxdiff = self.storedxdiff / 1.05

                end



                if self.ydiff > 0 and self.ydiff > self.storedydiff then

                    self.storedydiff = self.storedydiff + self.ydiff / 100

                elseif self.ydiff < 0 and self.ydiff < self.storedydiff then

                    self.storedydiff = self.storedydiff + self.ydiff / 100

                else

                    self.storedydiff = self.storedydiff / 1.05

                end

            end



            -- Adding obtained differentiation

            self.addPos.x = self.cosAngleY * self.storedxdiff + self.sinAngleY * self.storedydiff

            self.addPos.y = self.sinAngleY * self.storedxdiff - self.cosAngleY * self.storedydiff

            desiredPitch = math.deg(self.xdiff)

            desiredRoll = math.deg(self.ydiff)



            if ply:KeyDown(IN_DUCK) then

                local trace = util.QuickTrace(self:GetPos(), self:GetPos() - Vector(0, 0, -10))



                if self:GetPos().z - trace.HitPos.z < 2 then

                    enableControl = false

                    self.addPos.z = -0.04

                    self.addPos.x = 0

                    self.addPos.y = 0

                    self.xdiff = 0

                    self.ydiff = 0



                    if ply:KeyDown(IN_MOVELEFT) then

                        desiredYaw = desiredYaw + 30

                    elseif ply:KeyDown(IN_MOVERIGHT) then

                        desiredYaw = desiredYaw - 30

                    end



                    if ply:KeyDown(IN_FORWARD) then

                        self.addPos.x = self.cosAngleY * 0.03

                        self.addPos.y = self.sinAngleY * 0.03

                    elseif ply:KeyDown(IN_BACK) then

                        self.addPos.x = -self.cosAngleY * 0.03

                        self.addPos.y = -self.sinAngleY * 0.03

                    end

                end

            end



            if enableControl then

                if ply:KeyDown(IN_FORWARD) then

                    self.addPos.z = 0.13

                elseif ply:KeyDown(IN_BACK) then

                    self.addPos.z = -0.12

                end



                if ply:KeyDown(IN_MOVELEFT) then

                    desiredYaw = desiredYaw + 18

                    desiredPitch = desiredPitch + 100 * math.abs(self.ydiff) / 2

                    --desiredRoll = desiredRoll - 100 * math.abs(self.ydiff) / 2

                    --self.ydiff = self.ydiff / 1.05

                elseif ply:KeyDown(IN_MOVERIGHT) then

                    desiredYaw = desiredYaw - 18

                    desiredPitch = desiredPitch + 100 * math.abs(self.ydiff) / 2

                end

            end



            -- Exponential expanded velocity

            self.diffVel = math.min(math.exp(math.abs(self.xdiff) * 4.8 - 3) + math.exp(math.abs(self.ydiff) * 4 - 3), 12)

            -- Flying down with the absolute angular velocity

            self.addPos.z = self.addPos.z - math.Round(math.Remap(self.diffVel, 0, 9, 0, 2.5), 1)

            -- Changing the pitch of rotor like originally in Rust

            self.rotorSound:ChangePitch(math.Remap(self.diffVel, 0, 5, 100, 200), 0.5)

            --desiredRoll = desiredRoll - 100 * math.abs(self.ydiff) / 2

            --self.ydiff = self.ydiff / 1.05

            local mult = self.SpeedMult

            self.addPos:Mul(mult)

            local dist = math.Clamp(self.storedPos:Distance(self.addPos), 0, mult)

            local time = math.Remap(dist, 0, mult, 0, 1)

            local lerp = 1 - math.sin(time * math.pi * 0.5)

            self.addPos = LerpVector(lerp * delta + (delta * 0.4), self.storedPos, self.addPos)

            self.storedPos = self.addPos

            desiredPos = desiredPos + self.addPos

        end



        local randPos = Vector(math.sin(math.cos(CurTime())) * 10, math.sin(math.sin(CurTime())) * 10, 0) / 10

        randPos:Rotate(self:GetAngles())

        desiredPos = desiredPos + randPos

        --In order to limit rising but disabled 

        --if desiredPos.z > 50 then

        --desiredPos.z = 50

        --end

        local move = {}

        move.secondstoarrive = 0.5

        move.pos = desiredPos

        move.angle = Angle(desiredPitch, desiredYaw, desiredRoll)

        move.maxangular = 12000

        move.maxangulardamp = 100

        move.maxspeed = 6000

        move.maxspeeddamp = 10000

        move.dampfactor = 0.9

        move.teleportdistance = 0

        move.deltatime = delta



        if ply and ply:IsValid() then

            phys:ComputeShadowControl(move)

        else

            self.storedPos = Vector(0, 0, 0)

        end

    end

end



function ENT:Draw()

    self:DrawModel()

end


